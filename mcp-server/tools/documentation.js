/**
 * Documentation Generator Tool
 * Creates documentation from Anchor IDL
 */

import { promises as fs } from 'fs';
import path from 'path';

export async function generateDocs(args) {
  const { idlPath, format = 'markdown' } = args;
  
  if (!idlPath) {
    throw new Error('idlPath is required');
  }
  
  // Read IDL file
  const idlContent = await fs.readFile(idlPath, 'utf8');
  const idl = JSON.parse(idlContent);
  
  let documentation;
  
  switch (format) {
    case 'markdown':
      documentation = generateMarkdown(idl);
      break;
    case 'html':
      documentation = generateHTML(idl);
      break;
    case 'typescript':
      documentation = generateTypeScript(idl);
      break;
    default:
      throw new Error(`Unknown format: ${format}`);
  }
  
  const outputDir = path.join(process.cwd(), 'docs');
  await fs.mkdir(outputDir, { recursive: true });
  
  const extension = { markdown: 'md', html: 'html', typescript: 'ts' }[format];
  const sanitizedName = path.basename(idl.name);
  const outputPath = path.join(outputDir, `${sanitizedName}.${extension}`);
  
  await fs.writeFile(outputPath, documentation);
  
  return {
    success: true,
    idlName: idl.name,
    format,
    outputPath: `docs/${sanitizedName}.${extension}`,
    instructionCount: idl.instructions?.length || 0,
    accountCount: idl.accounts?.length || 0,
    typeCount: idl.types?.length || 0
  };
}

function generateMarkdown(idl) {
  let md = `# ${idl.name}\n\n`;
  md += `**Program ID:** \`${idl.metadata?.address || 'N/A'}\`\n\n`;
  
  if (idl.instructions && idl.instructions.length > 0) {
    md += `## Instructions\n\n`;
    
    for (const ix of idl.instructions) {
      md += `### ${ix.name}\n\n`;
      if (ix.docs) {
        md += `${ix.docs.join('\n')}\n\n`;
      }
      
      if (ix.args && ix.args.length > 0) {
        md += `**Arguments:**\n\n`;
        for (const arg of ix.args) {
          md += `- \`${arg.name}\`: ${formatType(arg.type)}\n`;
        }
        md += '\n';
      }
      
      if (ix.accounts && ix.accounts.length > 0) {
        md += `**Accounts:**\n\n`;
        for (const acc of ix.accounts) {
          md += `- \`${acc.name}\`: ${acc.isMut ? 'mut' : ''} ${acc.isSigner ? 'signer' : ''}\n`;
        }
        md += '\n';
      }
    }
  }
  
  if (idl.accounts && idl.accounts.length > 0) {
    md += `## Accounts\n\n`;
    
    for (const account of idl.accounts) {
      md += `### ${account.name}\n\n`;
      if (account.type?.fields) {
        md += '```rust\n';
        for (const field of account.type.fields) {
          md += `${field.name}: ${formatType(field.type)}\n`;
        }
        md += '```\n\n';
      }
    }
  }
  
  if (idl.types && idl.types.length > 0) {
    md += `## Types\n\n`;
    
    for (const type of idl.types) {
      md += `### ${type.name}\n\n`;
      if (type.type?.kind === 'enum') {
        md += '```rust\n';
        md += `enum ${type.name} {\n`;
        for (const variant of type.type.variants) {
          md += `  ${variant.name},\n`;
        }
        md += '}\n```\n\n';
      }
    }
  }
  
  md += `\n---\n\n*Generated by SolAgent Forge*\n`;
  
  return md;
}

function generateHTML(idl) {
  // Convert markdown to simple HTML
  const md = generateMarkdown(idl);
  let content = md
    // Escape HTML special chars first
    .replace(/&/g, '&amp;')
    .replace(/</g, '&lt;')
    .replace(/>/g, '&gt;')
    // Convert markdown headers to HTML
    .replace(/^# (.*?)$/gm, '<h1>$1</h1>')
    .replace(/^## (.*?)$/gm, '<h2>$1</h2>')
    .replace(/^### (.*?)$/gm, '<h3>$1</h3>')
    // Convert inline code
    .replace(/`([^`]+)`/g, '<code>$1</code>')
    // Convert code blocks
    .replace(/```rust\n([\s\S]*?)\n```/g, '<pre><code>$1</code></pre>')
    .replace(/```\n([\s\S]*?)\n```/g, '<pre><code>$1</code></pre>')
    // Convert lists
    .replace(/^\- (.*?)$/gm, '<li>$1</li>')
    // Convert bold
    .replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>')
    // Convert line breaks
    .replace(/\n\n/g, '</p><p>')
    .replace(/\n/g, '<br>');
  
  let html = `<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>${idl.name} Documentation</title>
  <style>
    body { font-family: sans-serif; max-width: 900px; margin: 40px auto; padding: 0 20px; line-height: 1.6; color: #333; }
    code { background: #f4f4f4; padding: 2px 6px; border-radius: 3px; font-family: monospace; }
    pre { background: #f4f4f4; padding: 15px; border-radius: 5px; overflow-x: auto; border-left: 3px solid #0066cc; }
    pre code { background: none; padding: 0; }
    h1 { border-bottom: 3px solid #0066cc; padding-bottom: 10px; color: #0066cc; }
    h2 { margin-top: 40px; border-bottom: 1px solid #ddd; padding-bottom: 8px; color: #333; }
    h3 { margin-top: 25px; color: #555; }
    li { list-style: none; padding: 5px 0; margin-left: 20px; }
    li:before { content: "â€¢ "; color: #0066cc; font-weight: bold; margin-right: 8px; }
    strong { color: #0066cc; font-weight: 600; }
    p { margin: 10px 0; }
  </style>
</head>
<body>
${content}
</body>
</html>`;
  
  return html;
}

function generateTypeScript(idl) {
  let ts = `/**\n * ${idl.name}\n * Program ID: ${idl.metadata?.address || 'N/A'}\n */\n\n`;
  
  ts += `export type ${pascalCase(idl.name)} = {\n`;
  ts += `  version: "${idl.version}";\n`;
  ts += `  name: "${idl.name}";\n`;
  ts += `  instructions: [\n`;
  
  if (idl.instructions) {
    for (const ix of idl.instructions) {
      ts += `    {\n`;
      ts += `      name: "${ix.name}";\n`;
      ts += `      accounts: [\n`;
      if (ix.accounts) {
        for (const acc of ix.accounts) {
          ts += `        { name: "${acc.name}"; isMut: ${acc.isMut}; isSigner: ${acc.isSigner}; }\n`;
        }
      }
      ts += `      ];\n`;
      ts += `      args: [\n`;
      if (ix.args) {
        for (const arg of ix.args) {
          ts += `        { name: "${arg.name}"; type: ${JSON.stringify(arg.type)}; }\n`;
        }
      }
      ts += `      ];\n`;
      ts += `    },\n`;
    }
  }
  
  ts += `  ];\n`;
  ts += `};\n`;
  
  return ts;
}

function formatType(type) {
  if (typeof type === 'string') return type;
  if (type.vec) return `Vec<${formatType(type.vec)}>`;
  if (type.option) return `Option<${formatType(type.option)}>`;
  if (type.defined) return type.defined;
  return JSON.stringify(type);
}

function pascalCase(str) {
  return str
    .split(/[-_]/)
    .map(word => word.charAt(0).toUpperCase() + word.slice(1))
    .join('');
}
